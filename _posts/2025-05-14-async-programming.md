
**Comparing Coroutines in C++ and Rust**

| **Aspect** | **C++ Coroutines** | **Rust Coroutines (async/await)** |
|:-------|:----------------|:-----------------------------|
| Syntax & Usage | Uses `co_await`, `co_yield`, `co_return` inside coroutine functions. |	Uses `async fn` and `.await`. |
| Return Type | Coroutine functions can return various types,<br> often requiring custom promise types and handle management. | `async fn` returns an object implementing the Future trait. |
| State Management | The coroutine's state (including suspension points) is managed<br> by the compiler and runtime, often requiring explicit handle manipulation. | The state machine is generated by the compiler,<br> and the runtime (like Tokio) schedules and polls these futures. |
| Scheduling | No built-in scheduler;<br> coroutines are "fire-and-forget" unless explicitly managed.<br> The user or library must schedule and resume them. | Requires an async runtime (e.g., Tokio, async-std) to poll and schedule futures. |
| Memory Safety	| Relies on C++'s memory model;<br> can be error-prone with manual memory management.	| Enforces strict memory safety via Rust's ownership and borrowing rules. |
| Flexibility	| Supports both stackless (standard) and<br> stackful (via libraries) coroutines.	| Only stackless coroutines are supported;<br> stackful coroutines are not part of Rust's async model. |
| Underlying Model | Awaitables continue the coroutine from the bottom up (the callee resumes the caller). | The runtime polls the future from the top down (the executor drives progress). |

C++20 officially added the [Coroutines](https://en.cppreference.com/w/cpp/language/coroutines) feature.
